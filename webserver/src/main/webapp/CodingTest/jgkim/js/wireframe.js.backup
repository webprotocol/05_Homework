/**
 * ▣  실기시험 : (40점 만점)
 * - 작성자 : 김진곤 (5강의실)
 * - 주 제 :
 * - 목 적 :
 * - 기 능 :
 */

(function() {

	var VisualEqualizer = (function() {

		VisualEqualizer.prototype.canvas = null;
		VisualEqualizer.prototype.context = null;
		VisualEqualizer.prototype.canvasWidth = 2000;
		VisualEqualizer.prototype.canvasHeight = 1000;
		VisualEqualizer.prototype.centerX = 0;
		VisualEqualizer.prototype.centerY = 0;
		VisualEqualizer.prototype.waveformStyle = null;

		VisualEqualizer.prototype.analyser = null;
		VisualEqualizer.prototype.run = null; //callback function

		function VisualEqualizer()
		{
			this.run = this.runRoutine.bind(this);
			this.initScreen();
			this.analyser = new Analyser();
			this.run();
		}

		VisualEqualizer.prototype.initScreen = function()
		{
			this.canvas = document.querySelector("canvas");
			this.context = this.canvas.getContext('2d');
			this.canvas.width = this.canvasWidth;
			this.canvas.height = this.canvasHeight;

			this.waveformStyle = this.context.createLinearGradient(0, 0, 0, this.canvasHeight);
			this.waveformStyle.addColorStop(0.00, "rgb(193, 8, 27)");
			this.waveformStyle.addColorStop(0.50, "rgb(210, 122, 238)");
			this.waveformStyle.addColorStop(1.00, "rgb(22, 20, 225)");
		};


		VisualEqualizer.prototype.runRoutine = function()
		{
			this.analyser.step();
			var spectrum = this.analyser.spectrum;
			var waveform = this.analyser.signal;
			var bandWidth = this.canvasWidth / spectrum.length;
			var padding = 5;

			/*
			 background color
			 */
			this.context.fillStyle = "rgb(234, 156, 180)";
			this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

			/*
			 Draw graph
			 */

			this.context.fillStyle = "rgba(124, 183, 239, .7)";
			for (var i = 0; i < spectrum.length; ++i)
			{
				var level = spectrum[i];
				this.context.fillRect(i * bandWidth + padding, this.canvasHeight, bandWidth - padding * 2, -level * this.canvasHeight);
				this.context.fillRect(this.canvasWidth - i * bandWidth - bandWidth + padding, 0, bandWidth - padding * 2, level * this.canvasHeight);
			}

			/*
			 Draw waveform
			 */
			bandWidth = this.canvasWidth / waveform.length;
			this.context.beginPath();
			this.context.strokeStyle = this.waveformStyle;
			this.context.lineWidth = 10;
			this.context.moveTo(0, this.canvasHeight / 2 + waveform[0] * this.canvasHeight / 3);
			for (i = 0; i < waveform.length; ++i)
				this.context.lineTo(i * bandWidth, this.canvasHeight / 2 + waveform[i] * this.canvasHeight / 3);
			this.context.stroke();
			return requestAnimationFrame(this.run);
		};

		return VisualEqualizer;
	})();


	function FourierTransform(bufferSize, sampleRate)
	{
		this.bufferSize = bufferSize;
		this.sampleRate = sampleRate;
		this.bandwidth  = bufferSize * sampleRate;
		this.spectrum   = new Float32Array(bufferSize/2);
		this.real       = new Float32Array(bufferSize);
		this.imag       = new Float32Array(bufferSize);
		this.peakBand   = 0;
		this.peak       = 0;

		this.getBandFrequency = function(index)
		{
			return this.bandwidth * index + this.bandwidth / 2;
		};
		this.calculateSpectrum = function()
		{
			var spectrum  = this.spectrum,
				real      = this.real,
				imag      = this.imag,
				bSi       = 2 / this.bufferSize,
				rval, ival, mag;
			this.peak = this.peakBand = 0;
			for (var i = 0, N = bufferSize*0.5; i < N; i++)
			{
				rval = real[i];
				ival = imag[i];
				mag = bSi * Math.sqrt(rval * rval + ival * ival);
				if (mag > this.peak)
				{
					this.peakBand = i;
					this.peak = mag;
				}
				spectrum[i] = mag;
			}
		};
	}

	function FFT(bufferSize, sampleRate)
	{
		FourierTransform.call(this, bufferSize, sampleRate);
		this.reverseTable = new Uint32Array(bufferSize);
		var limit = 1;
		var bit = bufferSize >> 1;
		var i;
		while (limit < bufferSize)
		{
			for (i = 0; i < limit; i++)
				this.reverseTable[i + limit] = this.reverseTable[i] + bit;
			limit = limit << 1;
			bit = bit >> 1;
		}
		this.sinTable = new Float32Array(bufferSize);
		this.cosTable = new Float32Array(bufferSize);
		for (i = 0; i < bufferSize; i++)
		{
			this.sinTable[i] = Math.sin(-Math.PI/i);
			this.cosTable[i] = Math.cos(-Math.PI/i);
		}
	};

	FFT.prototype.forward = function(buffer)
	{
		var bufferSize      = this.bufferSize,
			cosTable        = this.cosTable,
			sinTable        = this.sinTable,
			reverseTable    = this.reverseTable,
			real            = this.real,
			imag            = this.imag,
			spectrum        = this.spectrum;
		var k = Math.floor(Math.log(bufferSize) / Math.LN2);
		if (Math.pow(2, k) !== bufferSize)
			throw "Invalid buffer size, must be a power of 2.";
		if (bufferSize !== buffer.length)
			throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
		var halfSize = 1,
			phaseShiftStepReal,
			phaseShiftStepImag,
			currentPhaseShiftReal,
			currentPhaseShiftImag,
			off,
			tr,
			ti,
			tmpReal,
			i;
		for (i = 0; i < bufferSize; i++)
		{
			real[i] = buffer[reverseTable[i]];
			imag[i] = 0;
		}
		while (halfSize < bufferSize)
		{
			phaseShiftStepReal = cosTable[halfSize];
			phaseShiftStepImag = sinTable[halfSize];
			currentPhaseShiftReal = 1;
			currentPhaseShiftImag = 0;
			for (var fftStep = 0; fftStep < halfSize; fftStep++)
			{
				i = fftStep;
				while (i < bufferSize)
				{
					off = i + halfSize;
					tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
					ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);
					real[off] = real[i] - tr;
					imag[off] = imag[i] - ti;
					real[i] += tr;
					imag[i] += ti;
					i += halfSize << 1;
				}
				tmpReal = currentPhaseShiftReal;
				currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
				currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
			}
			halfSize = halfSize << 1;
		}
		return this.calculateSpectrum();
	};


	var Analyser = (function() {
		Analyser.prototype.audioFileName = "../2040khz.mp3";

		Analyser.prototype.aContext = null;
		Analyser.prototype.node = null;
		Analyser.prototype.analyser = null;
		Analyser.prototype.fanalyser = null;
		Analyser.prototype.audio = null;
		Analyser.prototype.bufferSize = 2 << 9;
		Analyser.prototype.signal = null;
		Analyser.prototype.fft = null;
		Analyser.prototype.amplitude = 0;
		Analyser.prototype.spectrum = [];
		Analyser.prototype.step = null;
		Analyser.prototype.processAudio = null;

		function Analyser()
		{
			this.step = this.step.bind(this);
			this.processAudio = this.processAudio.bind(this);
			this.signal = new Float32Array(this.bufferSize);
			this.fft = new FFT(this.bufferSize, 44100);
			this.aContext = new AudioContext();
			this.loadAudio();
		}

		Analyser.prototype.loadAudio = function()
		{
			this.audio = new Audio();
			this.audio.src = this.audioFileName;
			this.audio.crossOrigin = "anonymous";
			this.audio.preload = 'auto';
			this.audio.controls = true;
			document.body.appendChild(this.audio);
			this.audio.addEventListener('canplay', this.setupAudioNodes.bind(this));
		};

		Analyser.prototype.setupAudioNodes = function(e)
		{
			if (this.analyser == null)
			{
				this.analyser = this.aContext.createScriptProcessor(this.bufferSize, 2, 2);
				this.fanalyser = this.aContext.createAnalyser();
				this.analyser.onaudioprocess = this.processAudio;
				this.node = this.aContext.createMediaElementSource(this.audio);
				this.node.connect(this.fanalyser);
				this.fanalyser.connect(this.analyser);
				this.analyser.connect(this.aContext.destination);
			}
			this.audio.play();
		};

		Analyser.prototype.processAudio = function(event)
		{
			var inputArrayL = event.inputBuffer.getChannelData(0);
			var inputArrayR = event.inputBuffer.getChannelData(1);
			var outputArrayL = event.outputBuffer.getChannelData(0);
			var outputArrayR = event.outputBuffer.getChannelData(1);


			for (var i = 0; i < outputArrayL.length; ++i)
			{
				outputArrayL[i] = inputArrayL[i];
				outputArrayR[i] = inputArrayR[i];
				this.signal[i] = (inputArrayL[i] + inputArrayR[i]) / 2;
			}

			this.fft.forward(this.signal);
			var sum = this.fft.spectrum.reduce(function (sum, v) { return sum + v; }, 0);
			this.amplitude = 100 * sum / this.fft.spectrum.length;
		};

		Analyser.prototype.step = function()
		{
			var specLength = this.fft.spectrum.length;
			var totalBands = specLength / 32;
			var currentBand = -1;

			// var bandTotal;
			// for (var i = 0; i < specLength; ++i)
			// {
			// 	if (i % totalBands === 0)
			// 	{
			// 		bandTotal = 0;
			// 		currentBand++;
			// 	}
			// 	bandTotal += this.fft.spectrum[i];
			//
			// 	if (i % totalBands === totalBands - 1)
			// 		this.spectrum[currentBand] = bandTotal;
			// }

			if (this.fanalyser) {
				var freqData = new Uint8Array(this.fanalyser.frequencyBinCount);
				this.fanalyser.getByteFrequencyData(freqData);


				var bandTotal;
				var totalBands = freqData.length / 32;
				for (var i = 0; i < freqData.length; ++i)
				{
					if (i % totalBands === 0)
					{
						bandTotal = 0;
						currentBand++;
					}
					bandTotal += freqData[i];

					if (i % totalBands === totalBands - 1)
						this.spectrum[currentBand] = bandTotal / 15000;
				}

				console.log(this.spectrum[0]);
			}


		};

		return Analyser;

	})();


	new VisualEqualizer();
})();
